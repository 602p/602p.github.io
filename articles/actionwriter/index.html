<html>
	<head>
		<title>Actionwriter Conversion (louis.goessling.com)</title>
		<link rel="stylesheet" type="text/css" href="../../css/normalize.css">
		<link rel="stylesheet" type="text/css" href="../../css/skeleton.css">
		<link rel="stylesheet" type="text/css" href="../../css/util.css">
		<link rel="stylesheet" href="../../css/magnific-popup.css">
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400" rel="stylesheet">

		<link rel="stylesheet" type="text/css" href="actionwriter.css">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
		<script src="../../js/magnific-popup.min.js"></script>
		<script src="anim.js"></script>
	</head>
	<body>
		<div class="container">
			<div class="five pct tall"></div>
			<div class="row">
				<div class="twelve columns">
					<div class="u-block-centered">
						<h2>Actionwriter keyboard conversion for PC</h2>
						<b>or, how to get a Model M<sup>ish</sup> for only $10<sup>ish</sup></b>
					</div>
					<br/>

					<p>I'm a fan of mechanical keyboards. Now, I'm nowhere near as rabid of a fan as others who will hundreds of dollars on them (I'm actually kind of a cheapskate) but I have always wanted to own a Model M. I also have something of a soft spot for old typewriters, and I buy them at garage sales when I can. Of course, the logical intersection of these two interests is typewriter keyboards. A lot of old electromechanical typewriters have cool keyboards - both for the switches and the layout. I found an IBM Actionwriter 1 at a garage sale and these are the notes of how I've turned it's keyboard into a PC-compatible USB keyboard.</p>
					
					<div id="bucklespring-image-container">
						How a buckling spring keyswitch looks and sounds:
						<img id="bucklespring-image" src="bucklespring.gif" alt="Buckling spring keyswitch diagrammatic animation">
						<audio controls>
							<source src="bucklespring_sound.ogg" type="audio/ogg">
							Audio tag is not supported in this browser.
						</audio>
					</div>

					<p>The venerable Actionwriter is a electromechanical typewriter, meaning it has a keyboard that is connected to a microcontroller that in turn drives the mechanical equipment doing the type-writing. Most importantly, being a genuine 1985 West Germany-made IBM product it had a buckling spring keyboard. If you aren't up to date on <span class="tooltipd" title="This is the part of the keyboard that turns the motion of the peice of plastic with the letter printed on it into an electronically-readable signal">keyswitch</span> types, the buckling-spring is something of a holy grail (IMO, at least.) They have a great kinetic feel and are gloriously clicky. Unfortunately, Model Ms are <span class="tooltipd" title="I know, $100 isn't that expensive - but hey, I'm a student, and you remember the cheapskate comment">kinda</span> expensive because no matter how you cut it you have to have one of these complicated little assemblies for each key. </p>

					<p>To make the most of this article, you should know a little about programming and a little more about electronics. The majority of the code involved is just shuffling around data, so you should be able to get by as long as you can read C and Python. As far as the hardware, if you've used an Arduino before your probably good - I went into this having never meaningfully used <span class="tooltipd" title="Integrated Circuits. In this case two or three types of Dual-Inline Packages, or DIPs.">IC</span>s.</p>


					<h5>How does this thing connect, anyway?</h5>

					<p>The first step was to pop the top off the typewriter and take a closer look at the keyboard. The typewriter hides it's guts between two halves of a plastic shell that pop apart neatly to reveal it's <a class="popup" href="ceilrootn.gif">inner workings</a>. The keyboard itself then can be unplugged from the main <span class="tooltipd" title="Printed Circuit Board">PCB</span> by removing the three connectors. The keyboard is built on top of a single <a class="popup" href="ceilrootn.gif">curved metal piece</a> that also has a cutout to hold the status LEDs. The ribbon cable for driving the LEDs is one of the connectors back to the PCB. The other two are "Flexible Flat Cables" (FFCs) - you may have had the displeasure of working with these if you've ever torn apart a laptop or similarly compact device. These FFCs are not actually so bad - the cables and their contacts are <a class="popup" href="ceilrootn.gif">pretty big</a>.</p>

					<p>The microprocessor on the board in the Actionwriter is some sort of <b>80xx (CHIP?)</b> but the keyboard interface is obviously not PS/2, AT, or even that weird one that looks like SATA. A keyboard has to have a switch somewhere inside it for every key, but it would be absurd to wire every switch to it's own line - I/O pins are expensive! Manufacturers wire the keys together in a "keyboard matrix" to enable reading all of the inputs with a reasonable number of I/O lines. The keyboard, intended to be used only in the typewriter, exposed only the raw keyboard matrix lines.</p>


					<h5>Reading a keyboard matrix</h5>

					<div id="keyboard-matrix-container">
						<pre id="keyboard-matrix-animation">LOADING</pre>
						<button id="keyboard-matrix-playpause">Pause</button>&nbsp;&nbsp;<button id="keyboard-matrix-step">Step</button>
					</div>

					<p>The principle of a keyboard matrix is that we can select which out of a number of switches wired in parallel we want to read by driving the input of only one of them. This can then be extended to select a number of switches, each with their own input line. In this manner, if we have <code>n</code> I/O lines we can read <code>&lfloor;(n/2)^2&rfloor;</code> switches. The downside is that to read the state of all the switches we must go through a cycle of scanning each of the <code>&lfloor;n/2&rfloor;</code> banks of switches.</p>

					<p>The animation to the right depicts a matrix of 16 keys, where <code>O</code> represents open and <code>X</code> represents closed. As the selected column scans across each of the four (indicated by capitalization) we read each of the four rows, filling out columns in out table that eventually holds a complete image of the state of the keyboard. It's a lot like addressing a 2-dimensional array. Some helpful articles about this system with better illustrations are <a href="http://pcbheaven.com/wikipages/How_Key_Matrices_Works/" target="_blank" class="popout-icon-after">here</a> and <a href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/" target="_blank" class="popout-icon-after">here</a>. Code for this process is pretty simple and looks like: <br/>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #333399; font-weight: bold">bool</span> state[NR_ROWS][NR_COLS];
...
<span style="color: #333399; font-weight: bold">void</span> update_state(){
	memset(state, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> state);
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> col<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; col<span style="color: #333333">&lt;</span>NR_COLS; col<span style="color: #333333">++</span>){
		setColumnHigh(col);
		<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> row<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; col<span style="color: #333333">&lt;</span>NR_ROWS; row<span style="color: #333333">++</span>){
			state[row][col]<span style="color: #333333">=</span>readRow(row);
		}
	}
}
</pre></div>

</p>

					<p>I bought two <code>CONN FFC VERT 14POS 2.54MM PCB</code>s from DigiKey, who since seem to have discontinued them. These are <span class="tooltipd" title="Zero Insertion Force, which is sorta kinda true. Really it means that the hole for the connector is too big, you put it in (requiring no insertion force) and then move a lever (or something) and the hole becomes slightly smaller than the right size, clamping it in place.">ZIF</span> connectors for the FFCs on the keyboard to plug into. 2.54mm (0.1in) is the standard spacing for breadboards, and apparently also (or at least close enough to) the spacing of these FFC cables. The two connectors for the keyboard have 13 and 8 connected leads (the second has 15 connectors total, where the last 7 are connected to each other but not to the keyboard for some reason.) I stupidly bought 14-lead connectors, but I made it work by clipping off some of the extra plastic on the end of the 15-lead one that is all wired together.</p>

					<p>Now that I had them in front of me, I could hook them up to an Arduino Leonardo (selected for it's USB emulation capability) and make sure the connectors from the keyboard really <i>did</i> connect to the rows and columns of a matrix of switches. Yes, they do. However the 21 meaningful I/O lines required to read the keyboard's <span class="tooltipd" title="You might have noticed that this dosen't line up with the &lfloor;(n/2)^2&rfloor; equation from earlier. You are right! It should be possible to read 64 keys with only 16 I/O lines, because &lfloor;(16/2)^2&rfloor;==64, and this could be done by using the analog pins on the Arduino. However, the matrix is larger than this, and consequently has a bunch of holes in it since only 64 positions are connected. Unfortunately, every column has at least one key in it so we still need to scan them all.">64 keys</span> were beyond the Arduino Leonardo's <span class="tooltipd" title="Not counting the possibility of using the analog I/O pins as digital input and using the I2C pins as I/O, but even that only brings it to 20">13 I/O lines</span> And that's not even thinking of other things I might want I/O for on the keyboard controller.</p>


					<h5>Multiplexing our Matrix</h5>
					<div id="mux-container">
						Two 8:1 muxes as a 16:1:
						<div id="mux-img-container"><img id="mux-animation" src="anim/1.png"></div>
						<div><button id="mux-playpause">Pause</button>&nbsp;&nbsp;<button id="mux-step">Step</button></div>
						<div><input type="number" id="mux-input" onkeypress="return event.charCode >= 48 && event.charCode <= 57" placeholder="Enter a number">&nbsp;<input type="checkbox" id="mux-bindec"><span id="mux-bindec-text">dec</span></div>
					</div>

					<p>There is a pretty elegant solution to this problem. I bought a couple 8:1 de/multiplexers on DigiKey (part nr. <a href="https://www.digikey.com/product-detail/en/texas-instruments/CD4051BE/296-2057-5-ND/67305" target="_blank" class="popout-icon-after"><code>CD4051BE</code></a>.) These guys allow you to control which of their eight output pins are electrically connected to their one input pin by driving it's address lines. A de/multiplexer with <code>n</code> address lines allows selection between <code>2^n</code> different lines, so for an mux with eight lines there are <code>log<sub>2</sub>(8) = 3</code> address lines. Because we actually only ever want to drive the selected column <span class="tooltipd" title="This is how I did it at first, the same principle applies if you want to drive it low, which is what I ended up doing.">high</span>, and there is no reason we would want to not select <i>any</i> column, we don't actually need to spend an I/O pin on the input to the mux, we can just connect it to +3v3.</p>

					<p>I've called this chip a de/mux because it can be used to either control which of eight outputs is attached to an input as well as be used to control which of eight inputs is attached to an output. It's best thought of as a rotary switch connecting the one pin to one of the eight - this connection is bidirectional. Because of this, we can use it to select between which of the eight rows of the matrix we want to read - so we can use <code>log<sub>2</sub>(8) = 3</code> lines for address select and one for input to read all eight rows.</p>

					<p>It's not quite that simple for selecting our column, because there are not eight columns, but 13. 13 isn't even a power of 2! To select which of the 13 columns to light up, we will need to use <code>&lceil;log<sub>2</sub>(13)&rceil; = 4</code> address bits. We also need some way to join two 8:1 muxes into a <code>2<sup>4</sup> = 16</code>:1 mux. We can do this with a discrete transistor acting as a NOT gate. These multiplexers have a disable pin, which means that the one pin is disconnected from all of the eight. If we connect the high address bit to the disable pin of one mux, and the logical inverse of the high address bit to the disable of the other <span class="tooltipd" title="You could get equivilent behaviour by leaving them both enabled, sharing the address lines, and using this bit to switch which one's input you pull high/low. I just think this is a neater solution because the resulting device is functionally equivilent to a 16:1 (you could use it as a mux or demux.)">mux we can use it to switch between them</span>. Then, we connect the low three address bits to the address inputs of both muxes, joining them together into a 16:1 multiplexer. Selecting which column to light up is as simple as writing the bits of it's index out to the address channels:

					<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">setColumnHigh</span>(<span style="color: #333399; font-weight: bold">int</span> address){
  <span style="color: #008800; font-weight: bold">if</span>(<span style="color: #333333">!</span>((address<span style="color: #333333">&gt;=</span><span style="color: #0000DD; font-weight: bold">0</span>)<span style="color: #333333">&amp;&amp;</span>(address<span style="color: #333333">&lt;=</span><span style="color: #0000DD; font-weight: bold">15</span>))) error();

  digitalWrite(COL_MUX_ADDRESS_PINS[<span style="color: #0000DD; font-weight: bold">0</span>],  bitRead(address, <span style="color: #0000DD; font-weight: bold">0</span>));
  digitalWrite(COL_MUX_ADDRESS_PINS[<span style="color: #0000DD; font-weight: bold">1</span>],  bitRead(address, <span style="color: #0000DD; font-weight: bold">1</span>));
  digitalWrite(COL_MUX_ADDRESS_PINS[<span style="color: #0000DD; font-weight: bold">2</span>],  bitRead(address, <span style="color: #0000DD; font-weight: bold">2</span>));
  digitalWrite(COL_MUX_ADDRESS_PINS[<span style="color: #0000DD; font-weight: bold">3</span>],  bitRead(address, <span style="color: #0000DD; font-weight: bold">3</span>));
}
</pre></div><br/>
					Reading one of the eight rows through the mux is the same, but we only write <code>log<sub>2</sub>(8) = 3</code> address bits, and do a read from the :1 side after.
					</p>


					<h5>Putting the map back together</h5>

					<p>There are a couple things about the real system that are different from what I've been describing. If you've been reading the <span class="tooltipd" title="Hi!">tooltip text</span> you'll have seen some of them. The two important things are:
						<ol>
							<li>The keyboard only has 64 keys, but there are 104 places in the 13x8 keyboard matrix. Why? I'm not sure, but I have a hunch. The IBM Wheelwriter 5 shares the same keyboard layout as the Actionwriter 1, with the addition of five more keys on the left hand side (you can see that on page 12 of <a href="http://publications.lexmark.com/publications/pdfs/2007/typewriters/Wheelwriter-5.pdf" class="popout-icon-after" target="_blank">this pdf</a>.) I suspect it shares the same membrane and metal backplane as the Actionwriter, since if you <span class="tooltipd" title="I actually own two of these, and boltmodded (replacing the plastic rivets with bolts, as on a early Model M) the other because it's plastic frontpeice was cracked and the hammers fell out of their spots. Such is the eBay experience.">take apart the keyboard</span> from this typewriter there's another row of five contact pads without hammers/stems immediately to the left of the leftmost column of keys. On this subject, there's also a pad and stem immediately to the right of the brackets keys (under the top third of the return key, where backslash would normally be.) If I find aesthetically matching keys I may mod this keyboard to have a backslash and normal-sized enter. Regardless, the question still stands as to why not use a 9x8 matrix.
							<br/><br/>The important part is that there are "holes" in the matrix where no <span class="tooltipd" title="These will go high if you hit a bad enough rollover state. This keyboard dosen't have diodes or anything inside it to prevent rollover, it can only handle 3 or 4 keys down at the same time before going a little nuts :(.">physical key</span> will cause it to read connected. Unfortunately each of the 13 columns has at least one key in it, so we have to at least scan across them all. The real keyboard controller program avoids reading the state of the holes, though.</li>
							<li>If you've worked with this kinda DIY electronics before you'll have hit issues with bounce and noise left and right. One thing I did in this project that was pretty effective at helping the bounce/noise issues was to make it so "driving" a column meant grounding it. Then I enabled the built-in pull-up resistor on the pin I read from on the Arduino so that if it's not connected it will read high. It's then inverted in software. This really helps - I don't know enough about electronics to know <i>why</i> though :P</li>
						</ol>
					</p>

					<p>At this point there wasn't anything left to do besides put it together in hardware! The minimum necessary to be able to read the whole keyboard matrix is 3 8:1 muxes and the transistor to switch between them. You could probably go without the mux on the rows and the switching transistor if you wanted. The <a class="popup" href="ceilrootn.gif">controller as it exists on my desk</a> is only a little more complex than what I've described, because it has some hardware (shift registers) to run status LEDs.</p>

					<p>Once it's wired up the next step was to figure out the mapping of <code>(row, col)</code> matrix positions to keys. For this I wrote a small script for the Arduino that just dumped the entire state of the keyboard matrix over serial. This isn't how real keyboards work, and it sends a bunch of extra info (the holes in the matrix.)</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> COL_ADDRESS_PINS[<span style="color: #0000DD; font-weight: bold">4</span>] <span style="color: #333333">=</span> {<span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #0000DD; font-weight: bold">1</span>, <span style="color: #0000DD; font-weight: bold">4</span>, <span style="color: #0000DD; font-weight: bold">5</span>};
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> ROW_ADDRESS_PINS[<span style="color: #0000DD; font-weight: bold">3</span>] <span style="color: #333333">=</span> {<span style="color: #0000DD; font-weight: bold">6</span>, <span style="color: #0000DD; font-weight: bold">7</span>, <span style="color: #0000DD; font-weight: bold">8</span>};
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> ROW_READ_PIN        <span style="color: #333333">=</span> A0;

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">setup</span>(){
	<span style="color: #888888">//Configure the pins. Switch circuit is closed when it&#39;s low, so set the</span>
	<span style="color: #888888">// input pin to be high by default</span>
	pinMode(ROW_READ_PIN, INPUT_PULLUP);
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">4</span>; i<span style="color: #333333">++</span>) pinMode(COL_ADDRESS_PINS[i], OUTPUT);
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">3</span>; i<span style="color: #333333">++</span>) pinMode(ROW_ADDRESS_PINS[i], OUTPUT);

	Serial.begin(<span style="color: #0000DD; font-weight: bold">115200</span>);
	<span style="color: #008800; font-weight: bold">while</span> (<span style="color: #333333">!</span>Serial); <span style="color: #888888">//Initialize serial port and wait for connection</span>
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">loop</span>(){
	Serial.print(<span style="background-color: #fff0f0">&quot;[&quot;</span>);
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> col<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; col<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">13</span>; col<span style="color: #333333">++</span>){
		setColumnHigh(col);
		<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> row<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; row<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">8</span>; row<span style="color: #333333">++</span>){
			Serial.print(readRow(row));
		}
	}
	Serial.println(<span style="background-color: #fff0f0">&quot;]&quot;</span>);
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">setColumnHigh</span>(<span style="color: #333399; font-weight: bold">int</span> address){
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">4</span>; i<span style="color: #333333">++</span>)
		digitalWrite(COL_ADDRESS_PINS[i], bitRead(address, i));
}

<span style="color: #333399; font-weight: bold">bool</span> <span style="color: #0066BB; font-weight: bold">readRow</span>(<span style="color: #333399; font-weight: bold">int</span> address){
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">3</span>; i<span style="color: #333333">++</span>)
		digitalWrite(ROW_ADDRESS_PINS[i], bitRead(address, i));

	<span style="color: #008800; font-weight: bold">return</span> <span style="color: #333333">!</span>digitalRead(ROW_READ_PIN);
}
</pre></div>
					<br/>
					<p>There's a Python script in the repo for this project that displays the keyboard matrix as you type in real time. I used this to figure out the locations of keys in the matrix. This process was as simple as pulling up this tool and pressing keys, while writing the resulting <code>(column, row)</code> coordinates down in a <a href="https://github.com/602p/actionwriter/blob/master/live_tools/map.txt" class="popout-icon-after" target="_blank">text file</a>. This then gets parsed into a python data structure that is a dictionary associating <code>(column, row)</code> indices in the matrix with (arbitrary) pretty key names. The darker gray squares are the holes discussed earlier. <code>(12, 2)</code> is where backslash would be if there was a key to <span class="tooltipd" title="If you pop off the return key you can poke it with a pencil, since there isn't a alignment column in the stem there either (there is one in the stem right of the quote key.)">actuate it</span>. It looks like this:</p>
					<img src="map.png" class="u-image-centered"><br/>

					<h5><del>Arduino Contraption</del> &rarr; Keyboard</h5>

					<p>One quick optimization we're going to do is to make it so that we only care about the parts of the keyboard matrix that map to actual keys. The keyboard map above clearly indicates that holes make up something like 40% of the matrix. We will compute a bitmask representing which places in the matrix we care about, and we can have the Arduino only bother to read those spots.</p>

					<div class="row">
						<div class="eight columns">
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">mapping</span> <span style="color: #008800; font-weight: bold">import</span> mapping <span style="color: #888888">#Map of (col, row) to key name</span>

columns<span style="color: #333333">=</span>[[] <span style="color: #008800; font-weight: bold">for</span> _ <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #0000DD; font-weight: bold">13</span>)]
<span style="color: #008800; font-weight: bold">for</span> pos <span style="color: #000000; font-weight: bold">in</span> mapping<span style="color: #333333">.</span>keys():
	columns[pos[<span style="color: #0000DD; font-weight: bold">0</span>]]<span style="color: #333333">.</span>append(pos[<span style="color: #0000DD; font-weight: bold">1</span>])

masks<span style="color: #333333">=</span>[]
<span style="color: #008800; font-weight: bold">for</span> col <span style="color: #000000; font-weight: bold">in</span> columns:
	masks<span style="color: #333333">.</span>append([i <span style="color: #000000; font-weight: bold">in</span> col <span style="color: #008800; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #0000DD; font-weight: bold">8</span>)])

bitmasks<span style="color: #333333">=</span>[]
<span style="color: #008800; font-weight: bold">for</span> mask <span style="color: #000000; font-weight: bold">in</span> masks:
	bits<span style="color: #333333">=</span><span style="color: #007020">reversed</span>(<span style="color: #007020">map</span>(<span style="color: #007020">str</span>, <span style="color: #007020">map</span>(<span style="color: #007020">int</span>, mask)))
	<span style="color: #888888">#    ^switching endian so that the 0th bit is the 0th row</span>
	bitmasks<span style="color: #333333">.</span>append(<span style="background-color: #fff0f0">&quot;0b&quot;</span><span style="color: #333333">+</span><span style="background-color: #fff0f0">&quot;&quot;</span><span style="color: #333333">.</span>join(bits))

<span style="color: #007020">print</span>(bitmasks)
</pre></div>


						</div>
						<div class="four columns">
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .8em .1em .1em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #888888">//Into C syntax...</span>
<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333399; font-weight: bold">char</span>
MASK[<span style="color: #0000DD; font-weight: bold">13</span>] <span style="color: #333333">=</span> {
	<span style="color: #0000DD; font-weight: bold">0b00000001</span>,
	<span style="color: #0000DD; font-weight: bold">0b10001011</span>,
	<span style="color: #0000DD; font-weight: bold">0b01101111</span>,
	<span style="color: #0000DD; font-weight: bold">0b00000001</span>,
	<span style="color: #0000DD; font-weight: bold">0b01111010</span>,
	<span style="color: #0000DD; font-weight: bold">0b01011010</span>,
	<span style="color: #0000DD; font-weight: bold">0b01011010</span>,
	<span style="color: #0000DD; font-weight: bold">0b11111111</span>,
	<span style="color: #0000DD; font-weight: bold">0b11111111</span>,
	<span style="color: #0000DD; font-weight: bold">0b01111110</span>,
	<span style="color: #0000DD; font-weight: bold">0b01011010</span>,
	<span style="color: #0000DD; font-weight: bold">0b11111101</span>,
	<span style="color: #0000DD; font-weight: bold">0b01111011</span>
};
</pre></div>



						</div>
					</div><br/>

					<p>You can see that the resultant masks represent the same information as the keymap image above, but it's now column-major instead of row-major (i.e. it's been rotated 90&deg; right.) This is because we will be scanning <span class="tooltipd" title="This is how we've been thinking of it. It also means that we only have to change three instead of four address bits">column-by-column</span>. The other thing we are going to need to do is keep track of the state of the keyboard. USB Keyboards send events to inform the computer in the changes of the states of keys, so we need to keep track of the previous state so that we can send these events on the rising and falling edges.</p>

					<p>Next, we'll generate the mapping from these linear indexes to the keycodes we want to send using the Aruduino Leonardo's Keyboard <span class="tooltipd" title="If it is a keyboard, is it emulation?">emulation</span>. For letters and numbers this will be as straightforward as just spitting out the character. For others (e.g. ctrl) we will need to use the #defines from the Arduino keyboard library.</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">from</span> <span style="color: #0e84b5; font-weight: bold">mapping</span> <span style="color: #008800; font-weight: bold">import</span> mapping

columns<span style="color: #333333">=</span>[[] <span style="color: #008800; font-weight: bold">for</span> _ <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">range</span>(<span style="color: #0000DD; font-weight: bold">13</span>)]
<span style="color: #008800; font-weight: bold">for</span> pos <span style="color: #000000; font-weight: bold">in</span> mapping<span style="color: #333333">.</span>keys():
	columns[pos[<span style="color: #0000DD; font-weight: bold">0</span>]]<span style="color: #333333">.</span>append(pos[<span style="color: #0000DD; font-weight: bold">1</span>])

keymap<span style="color: #333333">=</span>[]
<span style="color: #008800; font-weight: bold">for</span> col, entries <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">enumerate</span>(columns):
	<span style="color: #008800; font-weight: bold">for</span> row <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">sorted</span>(entries):
		keymap<span style="color: #333333">.</span>append(mapping[(col, row)])

<span style="color: #007020">print</span>(keymap)

for_arduino<span style="color: #333333">=</span>[]
<span style="color: #008800; font-weight: bold">for</span> item <span style="color: #000000; font-weight: bold">in</span> keymap:
	<span style="color: #008800; font-weight: bold">if</span> <span style="color: #007020">len</span>(item)<span style="color: #333333">==</span><span style="color: #0000DD; font-weight: bold">1</span> <span style="color: #000000; font-weight: bold">and</span> item <span style="color: #000000; font-weight: bold">in</span> <span style="background-color: #fff0f0">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>:
		for_arduino<span style="color: #333333">.</span>append(<span style="background-color: #fff0f0">&quot;&#39;%s&#39;&quot;</span><span style="color: #333333">%</span>item)
	<span style="color: #008800; font-weight: bold">else</span>:
		for_arduino<span style="color: #333333">.</span>append({
			<span style="background-color: #fff0f0">&quot;code&quot;</span>: 	<span style="background-color: #fff0f0">&quot;KEY_LEFT_GUI&quot;</span>,
			<span style="background-color: #fff0f0">&quot;mar_rel&quot;</span>: 	<span style="background-color: #fff0f0">&quot;KEY_ESC&quot;</span>,
			<span style="background-color: #fff0f0">&quot;r_mar&quot;</span>: 	<span style="background-color: #fff0f0">&quot;KEY_LEFT_ALT&quot;</span>,
			<span style="color: #888888"># ...a bunch more omitted here...</span>
			<span style="background-color: #fff0f0">&quot;topleft&quot;</span>:	<span style="background-color: #fff0f0">&quot;&#39;~&#39;&quot;</span>,
			<span style="background-color: #fff0f0">&quot;semicolon&quot;</span>:	<span style="background-color: #fff0f0">&quot;&#39;;&#39;&quot;</span>
		}[item])

<span style="color: #007020">print</span>(<span style="background-color: #fff0f0">&quot;, &quot;</span><span style="color: #333333">.</span>join(for_arduino))
</pre></div><br/>

					<p>Then we take the output of this and plug it into an updated version of the previous controller code. We've also updated the controller to scan all 64 keys into a buffer, and to keep two copies of this buffer. We then send keyboard events on the rising and falling edges of all of those keys. The <code>delay(10)</code> is a lazy form of debouncing. A better approach would be to have an array <code>int cycles_down[64]</code> and determine some number of cycles through <code>loop()</code> to require a key to be down before counting it. This, however, is simple and the <span class="tooltipd" title="The poor rollover characteristcs mean I'm probably not going to be gaming on this thing">latency isn't a big deal</span>. Putting it together, these are the interestingly changed parts of a minimal keyboard controller:</p>

<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#include &lt;Keyboard.h&gt;</span>

<span style="color: #888888">//...</span>

<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333399; font-weight: bold">char</span> MASK[<span style="color: #0000DD; font-weight: bold">13</span>] <span style="color: #333333">=</span> {
	<span style="color: #0000DD; font-weight: bold">0b00000001</span>,
	<span style="color: #0000DD; font-weight: bold">0b10001011</span>,
	<span style="color: #0000DD; font-weight: bold">0b01101111</span>,
	<span style="color: #0000DD; font-weight: bold">0b00000001</span>,
	<span style="color: #0000DD; font-weight: bold">0b01111010</span>,
	<span style="color: #0000DD; font-weight: bold">0b01011010</span>,
	<span style="color: #0000DD; font-weight: bold">0b01011010</span>,
	<span style="color: #0000DD; font-weight: bold">0b11111111</span>,
	<span style="color: #0000DD; font-weight: bold">0b11111111</span>,
	<span style="color: #0000DD; font-weight: bold">0b01111110</span>,
	<span style="color: #0000DD; font-weight: bold">0b01011010</span>,
	<span style="color: #0000DD; font-weight: bold">0b11111101</span>,
	<span style="color: #0000DD; font-weight: bold">0b01111011</span>
};

<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">unsigned</span> <span style="color: #333399; font-weight: bold">char</span> MAP[<span style="color: #0000DD; font-weight: bold">64</span>] <span style="color: #333333">=</span> {KEY_LEFT_GUI, <span style="color: #0044DD">&#39; &#39;</span>, KEY_END, <span style="color: #0000DD; font-weight: bold">0</span>,
	<span style="color: #0000DD; font-weight: bold">0</span>, KEY_DELETE, KEY_LEFT_CTRL, KEY_LEFT_ALT, <span style="color: #0044DD">&#39;\t&#39;</span>, KEY_ESC,
	<span style="color: #0000DD; font-weight: bold">0</span>, KEY_LEFT_SHIFT, <span style="color: #0044DD">&#39;z&#39;</span>, <span style="color: #0044DD">&#39;q&#39;</span>, <span style="color: #0044DD">&#39;1&#39;</span>, <span style="color: #0044DD">&#39;`&#39;</span>, <span style="color: #0044DD">&#39;a&#39;</span>, <span style="color: #0044DD">&#39;x&#39;</span>, <span style="color: #0044DD">&#39;w&#39;</span>, <span style="color: #0044DD">&#39;2&#39;</span>,
	<span style="color: #0044DD">&#39;s&#39;</span>, <span style="color: #0044DD">&#39;c&#39;</span>, <span style="color: #0044DD">&#39;e&#39;</span>, <span style="color: #0044DD">&#39;3&#39;</span>, <span style="color: #0044DD">&#39;d&#39;</span>, <span style="color: #0044DD">&#39;b&#39;</span>, <span style="color: #0044DD">&#39;v&#39;</span>, <span style="color: #0044DD">&#39;t&#39;</span>, <span style="color: #0044DD">&#39;r&#39;</span>, <span style="color: #0044DD">&#39;4&#39;</span>, <span style="color: #0044DD">&#39;5&#39;</span>, <span style="color: #0044DD">&#39;f&#39;</span>, <span style="color: #0044DD">&#39;g&#39;</span>, <span style="color: #0044DD">&#39;n&#39;</span>, <span style="color: #0044DD">&#39;m&#39;</span>,
	<span style="color: #0044DD">&#39;y&#39;</span>, <span style="color: #0044DD">&#39;u&#39;</span>, <span style="color: #0044DD">&#39;7&#39;</span>, <span style="color: #0044DD">&#39;6&#39;</span>, <span style="color: #0044DD">&#39;j&#39;</span>, <span style="color: #0044DD">&#39;h&#39;</span>, <span style="color: #0044DD">&#39;,&#39;</span>, <span style="color: #0044DD">&#39;]&#39;</span>, <span style="color: #0044DD">&#39;i&#39;</span>, <span style="color: #0044DD">&#39;8&#39;</span>, <span style="color: #0044DD">&#39;+&#39;</span>, <span style="color: #0044DD">&#39;k&#39;</span>, <span style="color: #0044DD">&#39;.&#39;</span>, <span style="color: #0044DD">&#39;o&#39;</span>, <span style="color: #0044DD">&#39;9&#39;</span>,
	<span style="color: #0044DD">&#39;l&#39;</span>, <span style="color: #0044DD">&#39;/&#39;</span>, <span style="color: #0044DD">&#39;[&#39;</span>, <span style="color: #0044DD">&#39;p&#39;</span>, <span style="color: #0044DD">&#39;0&#39;</span>, <span style="color: #0044DD">&#39;-&#39;</span>, <span style="color: #0044DD">&#39;;&#39;</span>, <span style="color: #0044DD">&#39;\&#39;&#39;</span>, KEY_INSERT, KEY_RETURN,
	KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_BACKSPACE, KEY_HOME};

<span style="color: #333399; font-weight: bold">bool</span> state[<span style="color: #0000DD; font-weight: bold">64</span>];
<span style="color: #333399; font-weight: bold">bool</span> old_state[<span style="color: #0000DD; font-weight: bold">64</span>];

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">setup</span>(){
	<span style="color: #888888">//...</span>

	Keyboard.begin();

	memset(old_state, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> state);
}

<span style="color: #333399; font-weight: bold">void</span> <span style="color: #0066BB; font-weight: bold">loop</span>(){
	memset(state, <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #008800; font-weight: bold">sizeof</span> state);
	<span style="color: #888888">//Since we only write into the buffer sometimes, keep a count</span>
	<span style="color: #333399; font-weight: bold">int</span> state_pos <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>;

	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> col<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; col<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">13</span>; col<span style="color: #333333">++</span>){
		setColumnHigh(col);
		<span style="color: #888888">//Have to do this because we have to scan all columns</span>
		<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> row<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; row<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">8</span>; row<span style="color: #333333">++</span>){
			<span style="color: #008800; font-weight: bold">if</span>(bitRead(MASK[col], row)){
				state[state_pos] <span style="color: #333333">=</span> readRow(row);
				state_pos<span style="color: #333333">++</span>;
			}
		}
	}
	
	<span style="color: #008800; font-weight: bold">for</span>(<span style="color: #333399; font-weight: bold">int</span> i<span style="color: #333333">=</span><span style="color: #0000DD; font-weight: bold">0</span>; i<span style="color: #333333">&lt;</span><span style="color: #0000DD; font-weight: bold">64</span>; i<span style="color: #333333">++</span>){
		<span style="color: #888888">//For each key, send a press on the rising edge</span>
		<span style="color: #888888">// and a release on the falling edge</span>
		<span style="color: #008800; font-weight: bold">if</span>(state[i] <span style="color: #333333">&amp;&amp;</span> <span style="color: #333333">!</span>old_state[i]){
			Keyboard.press(MAP[i]);
		}<span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span>(<span style="color: #333333">!</span>state[i] <span style="color: #333333">&amp;&amp;</span> old_state[i]){
			Keyboard.release(MAP[i]);
		}
	}

	<span style="color: #888888">//Switch buffers</span>
	memcpy(old_state, state, <span style="color: #008800; font-weight: bold">sizeof</span> state);
	delay(<span style="color: #0000DD; font-weight: bold">10</span>);
}
</pre></div><br/>

					<p>This is a really minimal version. You'll see a couple <code><span style="color: #0000DD; font-weight: bold">0</span></code>s in there for keys that I haven't yet bound to anything: physically these are the LMar, TSet and TClr keys. It also simply has no way to type a bunch of stuff: backslash, F-keys, arrow keys or <span class="tooltipd" title="You could, of course, bind the `lock` key to caps lock but I much prefer to use it for ctrl and then use `code` for the GUI/Windows key. Since there is only one left modifier this is a lot more ergonomic (imo) than keeping caps lock and mapping GUI/Windows somewhere on the left column">caps lock</span>. Of course, this mapping is essentially arbitrary. If you buy one of these guys you can configure the keyboard to have whatever layout you'd like. The biggest issue is that the keyboard for the Actionwriter 1 simply has less keys than a normal computer keyboard. <br/>So: how to deal with this? Shifting!</p>

					<h5>Keyboard customization for fun and profit</h5>

					<p>You may have wondered at this point: Does the shift key work on this keyboard? The answer is yes! When you press Shift, it is reported to the computer as any other key, and the actual shifting is done inside your OS. In fact, the whole idea that we are assigning characters to keys is a little disingenuous - we're actually assigning scancodes to keys. The Arduino Keyboard library just makes it so that we can use characters and their constants to refer to the scancodes by what they map top on a US-Layout keyboard. That means that if you flash your Arduino with the code above and plug it into a system with a Workman layout the keycap with D printed on it <span class="tooltipd" title="You should want this...">will</span> type an H.</p>

					<p>The kind of shifting I have in mind to solve the too-few-keys problem is different. It's more like the "shifting" done by the Fn key on a laptop or compact keyboard. When you press the Fn key, it's not reported to the OS. It instead causes the microcontroller in the keyboard to emit different scancodes to the computer when you press the Fn key in concert with different physical keys. In this way, (some of) the physical keys on the keyboard end up with multiple scancodes: one normal, and one when "shifted" with the Fn key. This is what we are going to do on the Actionwriter keyboard, to allow you to use a hardware meta key to input keypresses for keys that the keyboard does not physically have.</p>

					<p>The easy approach is to simply factor out the logic of going linear-matrix-code &rarr; key into it's own function, then make decisions on how to overload that based on what keys are held down at the moment. We will do this, and then later look at a more complex but more elegant approach. The first thing we want to do on this front is to make it easier to identify the keys in the software running on the Arduino. This will allow us to use meaningful names instead of arbitrary numbers in our shifting logic. </p>

					<i>(Extending the previous Python snippet...)</i>

					<div class="row">
						<div class="eight columns">
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">with</span> <span style="color: #007020">open</span>(<span style="background-color: #fff0f0">&quot;defines.c&quot;</span>, <span style="background-color: #fff0f0">&#39;w&#39;</span>) <span style="color: #008800; font-weight: bold">as</span> fd:
	<span style="color: #008800; font-weight: bold">for</span> idx, item <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">enumerate</span>(keymap):
		fd<span style="color: #333333">.</span>write(<span style="background-color: #fff0f0">&quot;</span><span style="color: #666666; font-weight: bold; background-color: #fff0f0">\n</span><span style="background-color: #fff0f0">#define LK_&quot;</span><span style="color: #333333">+</span>item<span style="color: #333333">+</span><span style="background-color: #fff0f0">&quot; &quot;</span><span style="color: #333333">+</span><span style="color: #007020">str</span>(idx))
</pre></div>
						</div>
						<div class="four columns">
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #557799">#define LK_code 0</span>
<span style="color: #557799">#define LK_space 1</span>
<span style="color: #557799">#define LK_repeat 2</span>
</pre></div>
						</div>
					</div>
					<br/>

					<p>There are, of course, a lot more lines in the output than what I have on the right. I've just cut them off because they aren't very interesting. This represents the mapping from meaningful names to our arbitrary linear IDs. This allows us to write more complex code on the Arduino without magic numbers.</p>

					<p></p>

					<hr/>

					<div><img id="cat" src="cat.jpeg" align="right" valign="middle"><div align="right" valign="middle">I'm Louis. Contact me at <a href="mailto:louis@goessling.com" target="_blank" class="popout-icon-after">louis@goessling.com</a> or find me on GitHub at <a href="https://github.com/602p" target="_blank" class="popout-icon-after">602p</a>.
					<br/>I go to the U of MN. I'm the Sysadmin for the <a href="https://acm.umn.edu" target="_blank" class="popout-icon-after">ACM</a> chapter there.
					<br/>There are a handful of other things on this <a href="/">website</a>.</div></div>

					<hr/>
					<p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a><br />This article, "<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Actionwriter Conversion</span>" (including those original images and assets not named below) by <a xmlns:cc="http://creativecommons.org/ns#" href="https://louis.goessling.com/articles/actionwriter" property="cc:attributionName" rel="cc:attributionURL">Louis Goessling</a> is licensed under a <a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" class="popout-icon-after">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.</p>
					<p><b>CC-BY-* credits</b><ul><li>New Window/Popup icon <span class="popout-icon-after">(</span>) by Denis Klyuchnikov from the Noun Project</li><li>Buckling Spring diagram by <span class="tooltipd" title="User deleted, Wikimedia user page is a redlink - so removed here.">Shaddim</span> - <span class="int-own-work" lang="en">Own work</span>, <a href="https://creativecommons.org/licenses/by-sa/3.0" title="Creative Commons Attribution-Share Alike 3.0"  target="_blank" class="popout-icon-after">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=30568410"  target="_blank" class="popout-icon-after">Link</a></li>
					<li>The buckling spring audio clip is public domain from Wikipedia</li>
					</ul></p>
				</div>
			</div>
			<div class="five pct tall"></div>
		</div>
	</body>
</html>